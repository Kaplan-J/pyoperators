---
layout: post
title: 2. Operators
published: true
category: doc
---

h4. 2.1. <a name="using_operators"></a> Using operators

The @Operator@ class and its subclasses are function factories. It means that in order to perform computations using an operator class, we first need to create an instance of it

{% highlight python %}
A = FftOperator(1024)
{% endhighlight %}

and then use the instance as a function. The object @A@ is a Python callable and takes "numpy":http://numpy.scipy.org/ 's N-dimensional array object as inputs and outputs:

{% highlight python %}
>>> input = np.arange(1024, dtype=complex)
>>> output = A(input)
Info: Allocating (1024,) complex128 = 0.015625 MiB in FftOperator.
{% endhighlight %}

By using the operator in such a way, a no-side-effect policy is enforced: it is garanteed that the input array will not be modified and as a consequence, a new buffer would be allocated every time the operator is called.

Similarly to ufuncs, such behaviour can be changed by providing the output array:

{% highlight python %}
>>> output = np.empty(1024, dtype=complex)
>>> A(input, output)
{% endhighlight %}

"Inplace operations":#inplace can be performed in a similar way by providing the input array as the output.

In this documentation, the same term __operator__ will be used for the @Operator@ class, subclasses and instances, though the context will disambiguate the meaning.


h4. 2.2. <a name="manipulating_operators"></a> Manipulating operators

Operators are easy to manipulate: they can be multiplied by a scalar, combined by addition, composition, element-wise (Hadamard) multiplication or "partition":#partition. The synthax uses the usual arithmetic signs, but be careful that the @*@ sign currently stands for composition (and not element-wise multiplication), following the convention for linear operators.

{% highlight python %}
>>> o1 = DiagonalOperator([1.,2.])
>>> o2 = DiagonalOperator([1.,1.])
>>> (3*o1)([2., 2.])
array([  6.,  12.])
>>> (o1+o2)([2., 2.])
array([ 4.,  6.])
>>> (o1*o2)([2., 2.])  # same as o1(o2)
array([ 2.,  4.])
{% endhighlight %}

Unless an algebraic simplification is possible, the resulting operator is a composite operator:

<div class="definition">
|  *addition*       | @AdditionOperator@ |
|  *composition*    | @CompositionOperator@ |
|  *multiplication* | @MultiplicationOperator@ |
|/2.  *partition*   | @BlockOperator@, @BlockRowOperator@|
|@BlockDiagonalOperator@, @BlockColumnOperator@|
</div>
<hr>

The @*@ sign may be confusing when multiplying non-linear operators and currently, the only way to perform element-wise multiplication is to call the composite operator:

{% highlight python %}
>>> MultiplicationOperator([o1,o2])([2., 2.])
array([ 4.,  8.])
{% endhighlight %}

The conjugate, transpose, adjoint and inverse operators, when defined, can be obtained by using the following attributes:

<div class="definition">
| *conjugate* | @.C@ |
| *transpose* | @.T@ |
| *adjoint*   | @.H@ |
| *inverse*   | @.I@ |
</div>
<hr>

For example:

{% highlight python %}
>>> o = Operator()
>>> o.T.C is o.H
True
>>> o = Operator(flags='real,symmetric')
>>> o.T is o.H is o
True
{% endhighlight %}


h4. 2.3. <a name="creating_operators"></a> Creating a new operator

Operators can be created in two ways. The first one is to define a direct function which will replace the usual matrix-vector operation and to instantiate the @Operator@ class:

{% highlight python %}
>>> def f(x, out):
...     out[...] = 2 * x
>>> P = Operator(direct=f)
{% endhighlight %}

Transforming a single-argument "ufunc":http://docs.scipy.org/doc/numpy/reference/ufuncs.html into an @Operator@ instance is straightforward:

{% highlight python %}
>>> sqrt = Operator(direct=np.sqrt)
{% endhighlight %}

The alternative way is more flexible, it consists in subclassing the @Operator@ class:

{% highlight python %}
>>> class MyOperator(Operator):
...     def __init__(self, coef):
...         self.coef = coef          
...         Operator.__init__(self)
...     def direct(self, x, out):
...         out[...] = self.coef * x
...
... P = MyOperator(2)
{% endhighlight %}




h4. 2.4. <a name="operator_flags"></a> Operator's flags

An operator __P__ can have the following algebraic properties, accessible with the @flag@ attribute:

<div class="definition">
|  *linear*     | |
|  *square*     | input and output have the same shape |
|  *real*       | conj __P__  = __P__ |
|  *symmetric*  | __P__ ^T^   = __P__ |
|  *hermitian*  | __P__ ^H^   = __P__ |
|  *idempotent* | __P__ __P__ = __P__ |
|  *involutary* | __P__ __P__ = __I__ |
|  *orthogonal* | __P__ ^T^ __P__ = __I__ |
|  *unitary*    | __P__ ^H^ __P__ = __I__ |
</div>
<hr>

They can be set using the @flag@ keyword:

{% highlight python %}
>>> def f(x, out):
...     out[...] = -x
>>> P = Operator(direct=f, flags='symmetric,involutary')
{% endhighlight %}

or by using operator decorators:

{% highlight python %}
>>> @decorators.symmetric
... @decorators.involutary
... class MyOperator(Operator):
...     def direct(self, x, out):
...         out[...] = -x
...
... P = MyOperator()
{% endhighlight %}

These flags are used to simplify expressions:

{% highlight python %}
>>> C = Operator(flags='idempotent')
>>> C * C is C
True
>>> D = Operator(flags='involutary')
>>> D * D
IdentityOperator()
{% endhighlight %}




h4. 2.5. <a name="operator_rules"></a> Operator's rules
TBD.




h4. 2.6. <a name="associated_operators"></a> Operator's associated operators
TBD




h4. 2.7. <a name="operator_shapes"></a> Operator's input and output shapes

The @Operator@ class has a flexible way to deal with inputs and outputs. In particular, it can handle:
* inputs with explicit or unconstrained shapes
* outputs with explicit, implicit or unconstrained shapes.

<div class="definition">
*Explicit shape:* The shape of the operator's output (input) is explicit when the operator can only return (apply over) arrays of a specified shape.

*Implicit shape:* The shape of the operator's output is implicit if its shape can be obtained from the input shape and the method @reshapein@.

*Unconstrained shape:* The shape of the operator's output (input) is unconstrained if it does not depend on the input shape (if any input shape can be handled by the operator). In this case, the @shapeout@ (@shapein@) attribute is None and the method @reshapein@ (@reshapeout@) applied over the input (output) shape returns None.
</div>

If the input (output) shape is explicit, the operator's attribute @shapein@ (@shapeout@) is equal to that tuple. Otherwise, this attribute is equal to None.

h5. Operator with explicit input shape and explicit output shape.

The explicit shapes are specified using the the @shapein@ and @shapeout@ keywords. The following example appends a zero to a fixed-size input.

{% highlight python %}
>>> class Op(Operator):
...     def __init__(self, value):
...         Operator.__init__(self, shapein=3, shapeout=4)
...         self.value = value
...     def direct(self, input, output):
...         output[0:3] = input
...         output[3] = self.value
>>> op = Op(0.)
>>> op.shapein, op.shapeout
((3,), (4,))
>>> op([3., 2. ,1.])
array([3., 2., 1., 0.])
{% endhighlight %}


h5. Operator with unconstrained input shape and explicit output shape.

Such operator is obtained by only setting the @shapeout@ keyword. The following example returns an array of size 2 whose elements are the sum and product of the elements of the input.

{% highlight python %}
>>> class Op(Operator):
...     def __init__(self):
...         Operator.__init__(self, shapeout=2)
...     def direct(self, input, output):
...         output[0] = np.sum(input)
...         output[1] = np.product(input)
>>> op = Op()
>>> op.shapein, op.shapeout
(None, (2,))
>>> op([1., 2., 3., 4.])
array([ 10., 24.])
{% endhighlight %}


h5. Operator with explicit input shape and implicit output shape

This case does not happen because the output shape can be obtained from the explicit input shape and the 'reshapein' method.

h5. Operator with unconstrained input shape and implicit output shape

To obtain such operator, one simply has to define a @reshapein@ method, which takes the input shape as input and returns the output shape. The following example stretches the input by a factor 2 along the first dimension.

{% highlight python %}
>>> class Op(Operator):
...     def __init__(self):
...         Operator.__init__(self)
...     def direct(self, input, output):
...         output[::2,...] = input
...         output[1::2,...] = input
...     def reshapein(self, shapein):
...         if shapein is None:
...             return None
...         return (2*shapein[0],) + shapein[1:]
>>> op = Op()
>>> op.shapein, op.shapeout
(None, None)
>>> op.reshapein((2,3))
(4,3)
>>> op([[1,2,3],[2,3,4]])
array([[1, 2, 3],
       [1, 2, 3],
       [2, 3, 4],
       [2, 3, 4]])
{% endhighlight %}


h5. Operator with explicit input shape and unconstrained output shape

Such operator is obtained by only setting the @shapein@ keyword. The following example fills the output with an arithmetic progression whose coefficients are given by the two elements of the input.

{% highlight python %}
>>> class Op(Operator):
...     def __init__(self):
...         Operator.__init__(self, shapein=2)
...     def direct(self, input, output):
...         output[...] = input[0] + input[1] * np.arange(output.size).reshape(output.shape)
>>> op = Op()
>>> op.shapein, op.shapeout
((2,), None)
>>> output = np.empty((2,2))
>>> op([1,2], output)
array([[1,3],[5,7]])
{% endhighlight %}


h5. Operator with unconstrained input and output shape

This kind of operator is the default: this behaviour is obtained by not setting the @shapein@ and @shapeout@ keywords and not defining the @reshapein@ method. The following example fills the output with the value of the sum of the elements of the input.

{% highlight python %}
>>> class Op(Operator):
...     def __init__(self):
...         Operator.__init__(self)
...     def direct(self, input, output):
...         output[...] = np.sum(input)
>>> op = Op()
>>> op.shapein, op.shapeout
(None, None)
>>> output = np.empty((2,2))
>>> op([2,1], output)
array([[3., 3.], [3., 3.]])
{% endhighlight %}




h4. <a name="operator_dtype"></a> 2.8. Operator's data type

The operator's data type is a data type object (an instance of "numpy.dtype":http://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html class). It can be set using the @dtype@ keyword.

{% highlight python %}
>>> a = Operator(dtype=np.float32)
>>> a.dtype
dtype('float32')
{% endhighlight %}

It is used to determine the output data type, as being the common type of the operator and input data types, following the standard coercion rules. For example:

{% highlight python %}
>>> a = DiagonalOperator([1,2])
>>> a.dtype
dtype('int64')
>>> a([1, 1j]).dtype
dtype('complex128')
>>> a(np.array([2,2], np.uint8)).dtype
dtype('int64')
{% endhighlight %}

The operator's data type can be equal to None (the default), in which case the output data type is always the input data type.




h4. <a name="class_propagation"></a> 2.9. Class propagation

An operator propagates the class of the input array, if the latter subclasses @numpy.ndarray@:

{% highlight python %}
>>> class ndarray2(np.ndarray):
...     pass
>>> type(I(ndarray2((2,2))))
__main__.ndarray2
{% endhighlight %}

It is possible to change the subclass too, by using the @classout@ keyword:

{% highlight python %}
>>> class ndarray3(np.ndarray):
...     pass
>>> I2 = IdentityOperator(classout=ndarray3)
>>> type(I2(ndarray((2,2))))
__main__.ndarray3
>>> type(I2(ndarray2((2,2))))
__main__.ndarray3
{% endhighlight %}



h4. <a name="attribute_propagation"></a> 2.10. Attribute propagation

An operator also propagates attributes:

{% highlight python %}
>>> class ndarray2(np.ndarray):
...     pass
>>> x = ndarray2((2,2))
>>> x.foo = 'bar'
>>> I(x).foo
'bar'
{% endhighlight %}

It is also possible to add or change an attribute, by setting the @attrout@ keyword to a dictionary whose keys are the attribute names and whose values are the attribute values:

{% highlight python %}
>>> I2 = IdentityOperator(attrout={'foo':'new_bar'})
>>> I2(x).foo
'new_bar'
>>> x.foo
'bar'
>>> I2(np.ones((2,2))).foo
'new_bar'
{% endhighlight %}

More flexibility is possible by passing a function, instead of a dictionary, to the @attrout@ keyword. This function expects a dictionary whose keys are the attribute names and whose values are the attribute values (it is the output's @__dict__@):

{% highlight python %}
>>> class I2Operator(IdentityOperator):
...     def __init__(self):
...         IdentityOperator.__init__(self, attrout=self.add_history)
...     def add_history(self, attr):
...         from time import ctime
...         if 'history' not in attr:
...             attr['history'] = []
...         attr['history'] += [ctime() + ' : ' + self.__class__.__name__]
>>> I2 = I2Operator()
>>> I2(I2(0)).history
{% endhighlight %}



h4. <a name="inplace"></a> 2.11. Inplace operation
TBD




h4. <a name="inplace_reductions"></a> 2.12. Inplace reductions

<div class="definition">
An operator that can do inplace reductions is an operator that can add, multiply (or else) its output to its output argument.
</div>

One can enable such property by adding the keyword @operation@ to the operator's direct method.

{% highlight python %}
>>> class P(Operator):
...     def direct(self, input, output, operation=assignment_operation):
...         operation(output, input)
... Q = sum(P() for k in range(0,3))
... output = np.empty(2)
... Q([1.,2.], output)
array([ 3.,  6.])
{% endhighlight %}

Note that this call has not required any memory allocation: all operations have been performed inplace. For the first operand, the @direct@ method of @Q@, which is an @AdditionOperator@, calls @P@ 's @direct@ method without the @operation@ keyword and consequently, the default function @assignment_function@ is used, which simply assigns the input to the output argument. The subsequent calls to @P@ set the @operation@ keyword to the @__iadd__@ method from Python's @operator@ module, which result in adding the input into the output argument inplace. This property is even more interesting for cache locality when an operator's output is zero, except for a few values: in such a case, the operator would only have to update the non-zero values:

{% highlight python %}
>>> @decorators.linear
... class Projection(Operator):
...     def __init__(self, index):
...          self.index = index
...          Operator.__init__(self, shapein=1, shapeout=11)
...     def direct(self, input, output, operation=assignment_operation):
...         if operation is assignment_operation:
...             output[...] = 0
...         elif operation is not operator.__iadd__:
...             raise NotImplementedError()
...         output[self.index] += input
... Q = Projection(0) + Projection(5) + Projection(10)
... output = np.empty(11)
... Q([2.], output)
array([ 2.,  0.,  0.,  0.,  0.,  2.,  0.,  0.,  0.,  0.,  2.])
{% endhighlight %}


h4. <a name="partition"></a> 2.13. Operator partition

Currently, there are two ways to partition operators, depending on whether the partitioning is done in an already existing dimension or not.

<div class="definition">
|*Stack partition:*| outputs are stacked along a new dimension|
|*Chunk partition:*| outputs are concatenated along an existing dimension|
</div>
<hr>

h5. Stack partition

A stack partition operator is the operator @BlockRowOperator@, initialised with the @new_axisin@ keyword, the operator @BlockDiagonalOperator@ with the keywords @new_axisin@ or @new_axisout@ or the operator @BlockColumnOperator@, initialised with the @new_axisout@ keyword. There is a strong constraint on the input and output shapes of the blocks, since they must be the same for all blocks. The partition along the specified axis is always explicit and is equal to a tuple of ones with as many elements as the number of blocks. In the following example is shown a stack partition block column operator:

{% highlight python %}
>>> C = BlockColumnOperator([I, 2*I, 3*I], new_axisout=0)
>>> C(np.ones(2))
array([[ 1.,  1.],
       [ 2.,  2.],
       [ 3.,  3.]])
{% endhighlight %}

The outputs of the blocks are stacked along the dimension specified by @new_axisout@ keyword, i.e the first one. The following example shows a stack partition block diagonal operator:

{% highlight python %}
>>> D = BlockDiagonalOperator([I, 2*I, 3*I], new_axisin=-1)
>>> x = np.arange(2*3).reshape((2,3))
>>> x
array([[0, 1, 2],
       [3, 4, 5]])
>>> D(x)
array([[ 0,  2,  6],
       [ 3,  8, 15]])
{% endhighlight %}

It can be seen that the first block @I@ is applied over @x[:,0]@, the second block @2*I@ over @x[:,1]@, and the third block @3*I@ over @x[:,2]@.

h5. Chunk partition

A chunk partition operator is the operator @BlockRowOperator@, initialised with the @axisin@ keyword, the operator @BlockDiagonalOperator@ with the keywords @axisin@ or @axisout@ or the operator @BlockColumnOperator@, initialised with the @axisout@ keyword. There is a lesser constraint on the shapes of the partitioned input and output of the blocks: all dimensions must be same except along the partitioned dimension(s). The partition along the specified axis can be implicit or explicit, in which case the keywords @partitionin@ or @partitionout@ are set to this explicit partition. The following example shows a block diagonal chunk partition operator with an explicit partition

{% highlight python %}
>>> D = BlockDiagonalOperator([I, 2*I, 3*I], axisin=-1, partitionin=(2,3,2))
>>> D(np.ones(7))
array([ 1.,  1.,  2.,  2.,  2.,  3.,  3.])
{% endhighlight %}

in which each block is an homothety. It can be seen that the first block @I@ is applied over the two first elements, the second block @2*I@ over the three following elements, and the third block @3*I@ over the last two elements. Block row and block column chunk partition operators can handle implicit partitions:

{% highlight python %}
>>> C = BlockColumnOperator([I, 2*I, 3*I], axisout=-1)
>>> C(np.ones((2,2)))
array([[ 1.,  1.,  2.,  2.,  3.,  3.],
       [ 1.,  1.,  2.,  2.,  3.,  3.]])
{% endhighlight %}

Likewise, the outputs of the blocks are concatenated along the dimension specified by the @axisout@ keyword, i.e the last one.




h4. <a name="list"></a> 2.14. List of available operators

h5. Linear operators

* AdditionOperator
* BandOperator
* BlockRowOperator
* BlockDiagonalOperator
* BlockColumnOperator
* CompositionOperator
* DiagonalOperator
* EigendecompositionOperator
* IdentityOperator
* MaskOperator
* MultiplicationOperator
* PackOperator
* ReshapeOperator
* ScalarOperator
* SymmetricBandOperator
* TridiagonalOperator
* UnpackOperator
* WaveletOperator
* Wavelet2Operator
* ZeroOperator


h5. Non-linear operators

* ClipOperator
* MaximumOperator
* MinimumOperator
* NumexprOperator
* RoundOperator

More operators can be found in the project "Tamasis/PACS":http://pchanial.github.com/tamasis-map, such as complex and real fft operators, convolution, projection, discrete differences, compression, downsampling, MPI operators, etc.
There is an on-going work consisting in migrating the most generic ones into the pyoperators package.
