---
layout: post
title: 2. Operators
published: true
category: doc
---

h4. 2.1. <a name="manipulation"></a> Manipulating operators

Operators are easy to manipulate: they can be multiplied by a scalar, combined by addition, composition, elementwise (Hadamard) multiplication or "partition":#partition.

The synthax uses the usual arithmetic signs, but be careful that the @*@ sign currently stands for composition (and not elementwise multiplication), following the convention for linear operators.

{% highlight python %}
>>> o1 = DiagonalOperator([1.,2.])
>>> o2 = DiagonalOperator([1.,1.])
>>> (3*o1)([2., 2.])
array([  6.,  12.])
>>> (o1+o2)([2., 2.])
array([ 4.,  6.])
>>> (o1*o2)([2., 2.])  # same as o1(o2)
array([ 2.,  4.])
{% endhighlight %}

 Unless an algebraic simplification is possible, the resulting operator is a composite operator:

<div class="definition" style="float:left;">
|  *addition*       | @AdditionOperator@ |
|  *composition*    | @CompositionOperator@ |
|  *multiplication* | @MultiplicationOperator@ |
|/2.  *partition*   | @BlockOperator@, @BlockRowOperator@|
|@BlockDiagonalOperator@, @BlockColumnOperator@|
</div>

<hr>

The @*@ sign may be confusing when multiplying non-linear operators and currently, the only way to perform elementwise multiplication is to call the composite operator:

{% highlight python %}
>>> MultiplicationOperator([o1,o2])([2., 2.])
array([ 4.,  8.])
{% endhighlight %}




h4. 2.2. <a name="creation"></a> Creating a new operator

Operators can be created in two ways. The first one is to define a direct function which will replace the usual matrix-vector operation and to instantiate the @Operator@ class:

{% highlight python %}
>>> def f(x, out):
...     out[...] = 2 * x
>>> P = Operator(direct=f)
{% endhighlight %}

Transforming a single-argument "ufunc":http://docs.scipy.org/doc/numpy/reference/ufuncs.html into an @Operator@ is straightforward:

{% highlight python %}
>>> sqrt = Operator(direct=numpy.sqrt)
{% endhighlight %}

The alternative way is more flexible, it consists in subclassing the @Operator@ class:

{% highlight python %}
>>> class MyOperator(Operator):
...     def __init__(self, coef):
...         self.coef = coef          
...         Operator.__init__(self)
...     def direct(self, x, out):
...         out[...] = self.coef * x
...
... P = MyOperator(2)
{% endhighlight %}




h4. 2.3. <a name="flags"></a> Operator's flags

An operator __P__ can have the following algebraic properties, accessible with the @flag@ attribute:

<div class="definition" style="float:left;">
|  *linear*     | |
|  *real*       | conj __P__  = __P__ |
|  *symmetric*  | __P__ ^T^   = __P__ |
|  *hermitian*  | __P__ ^H^   = __P__ |
|  *idempotent* | __P__ __P__ = __P__ |
|  *involutary* | __P__ __P__ = __I__ |
|  *orthogonal* | __P__ ^T^ __P__ = __I__ |
|  *unitary*    | __P__ ^H^ __P__ = __I__ |
</div>

<hr>

They can be set using the @flag@ keyword:

{% highlight python %}
>>> def f(x, out):
...     out[...] = -x
>>> P = Operator(direct=f, flags='symmetric,involutary')
{% endhighlight %}

or by using operator decorators:

{% highlight python %}
>>> @decorators.symmetric
... @decorators.involutary
... class MyOperator(Operator):
...     def direct(self, x, out):
...         out[...] = -x
...
... P = MyOperator()
{% endhighlight %}

These flags are used to simplify expressions:

{% highlight python %}
>>> C = pyoperators.Operator(flags='idempotent')
>>> C * C is C
True
>>> D = pyoperators.Operator(flags='involutary')
>>> D * D
IdentityOperator()
{% endhighlight %}




h4. 2.4. <a name="rules"></a> Operator's rules
TBD.




h4. 2.5. <a name="associated"></a> Operator's associated operator
TBD




h4. 2.6. <a name="shapes"></a> Operator's input and output shapes

The @Operator@ class has a flexible way to deal with inputs and outputs. In particular, it can handle:
* inputs with explicit or unconstrained shapes
* outputs with explicit, implicit or unconstrained shapes.

<div class="definition">
*Explicit shape:* The shape of the operator's output (input) is explicit when the operator can only return (apply over) arrays of a specified shape.

*Implicit shape:* The shape of the operator's output is implicit if its shape can be obtained from the input shape and the method @reshapein@.

*Unconstrained shape:* The shape of the operator's output (input) is unconstrained if it does not depend on the input shape (if any input shape can be handled by the operator). In this case, the @shapeout@ (@shapein@) attribute is None and the method @reshapein@ (@reshapeout@) applied over the input (output) shape returns None.
</div>

If the input (output) shape is explicit, the operator's attribute @shapein@ (@shapeout@) is equal to that tuple. Otherwise, this attribute is equal to None.


h5. Operator with explicit input shape and explicit output shape.

The explicit shapes are specified using the the @shapein@ and @shapeout@ keywords.

{% highlight python %}
>>> class Op(Operator):
...     def __init__(self, value):
...         Operator.__init__(self, shapein=3, shapeout=4)
...         self.value = value
...     def direct(self, input, output):
...         output[0:3] = input
...         output[3] = self.value
>>> op = Op(0.)
>>> op.shapein, op.shapeout
((3,), (4,))
>>> op([3., 2. ,1.])
array([3., 2., 1., 0.])
{% endhighlight %}


h5. Operator with unconstrained input shape and explicit output shape.

Such operator is obtained by only setting the @shapeout@ keyword.

{% highlight python %}
>>> class Op(Operator):
...     def __init__(self):
...         Operator.__init__(self, shapeout=2)
...     def direct(self, input, output):
...         output[0] = np.sum(input)
...         output[1] = np.product(input)
>>> op = Op()
>>> op.shapein, op.shapeout
(None, (2,))
>>> op([1., 2., 3., 4.])
array([ 10., 24.])
{% endhighlight %}


h5. Operator with explicit input shape and implicit output shape

This case does not happen because the output shape can be obtained from the explicit input shape and the 'reshapein' method.


h5. Operator with unconstrained input shape and implicit output shape

To obtain such operator, one only has to define a @reshapein@ method.

{% highlight python %}
>>> class Op(Operator):
...     def __init__(self):
...         Operator.__init__(self)
...     def direct(self, input, output):
...         output[::2,...] = input
...         output[1::2,...] = input
...     def reshapein(self, shapein):
...         if shapein is None:
...             return None
...         return (2*shapein[0],) + shapein[1:]
>>> op = Op()
>>> op.shapein, op.shapeout
(None, None)
>>> op.reshapein((2,3))
(4,3)
>>> op([[1,2,3],[2,3,4]])
array([[1, 2, 3],
       [1, 2, 3],
       [2, 3, 4],
       [2, 3, 4]])
{% endhighlight %}


h5. Operator with explicit input shape and unconstrained output shape

Such operator is obtained by only setting the @shapein@ keyword.

{% highlight python %}
>>> class Op(Operator):
...     def __init__(self):
...         Operator.__init__(self, shapein=2)
...     def direct(self, input, output):
...         output[...] = input[0] + input[1] * np.arange(output.size).reshape(output.shape)
>>> op = Op()
>>> op.shapein, op.shapeout
((2,), None)
>>> output = np.empty((2,2))
>>> op([1,2], output)
array([[1,3],[5,7]])
{% endhighlight %}


h5. Operator with unconstrained input and output shape

This kind of operator is the default: this behaviour is obtained by not setting the @shapein@ and @shapeout@ keywords and not defining the @reshapein@ method.

{% highlight python %}
>>> class Op(Operator):
...     def __init__(self):
...         Operator.__init__(self)
...     def direct(self, input, output):
...         output[...] = np.sum(input)
>>> op = Op()
>>> op.shapein, op.shapeout
(None, None)
>>> output = np.empty((2,2))
>>> op([2,1], output)
array([[3., 3.], [3., 3.]])
{% endhighlight %}




h4. <a name="dtype"></a> Operator's data type
TBD




h4. <a name="inplace"></a> Inplace operation
TBD




h4. <a name="reduction"></a> Inplace reduction
TBD




h4. <a name="partition"></a> Operator partition
TBD




h4. <a name="list"></a> List of available operators
TBD




