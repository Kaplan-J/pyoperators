---
layout: post
title: 2. Operators
published: true
category: doc
---

h4. 2.1. Manipulating operators

h4. 2.2. Creating a new operator

h4. 2.3. Operator's input and output shapes

An @Operator@ can handle inputs with
   - explicit shape,
   - unconstrained shape.
and outputs with
   - explicit shape,
   - implicit shape,
   - unconstrained shape.

*Explicit shape:* The shape of the operator's output (input) is explicit when the operator can only return (apply over) arrays of a specified shape.

*Implicit shape:* The shape of the operator's output is implicit if its shape can be obtained from the input shape and the method @reshapein@.

*Unconstrained shape:* The shape of the operator's output (input) is unconstrained if it does not depend on the input shape (if any input shape can be handled by the operator). In this case, the @shapeout@ (@shapein@) attribute is None and the method @reshapein@ (@reshapeout@) applied over the input (output) shape returns None.

If the input (output) shape is explicit, the operator's attribute @shapein@ (@shapeout@) is equal to that tuple. Otherwise, this attribute is equal to None.


h5. Explicit input shape and explicit output shape.

{% highlight python %}
>>> class Op(Operator):
        def __init__(self, value):
            Operator.__init__(self, shapein=3, shapeout=4)
            self.value = value
        def direct(self, input, output):
            output[0:3] = input
            output[3] = self.value
>>> op = Op(0.)
>>> op.shapein, op.shapeout
((3,), (4,))
>>> op([3., 2. ,1.])
array([3., 2., 1., 0.])
{% endhighlight %}


h5. Unconstrained input shape and explicit output shape.

{% highlight python %}
>>> class Op(Operator):
        def __init__(self):
            Operator.__init__(self, shapeout=2)
        def direct(self, input, output):
            output[0] = np.sum(input)
            output[1] = np.product(input)
>>> op = Op()
>>> op.shapein, op.shapeout
(None, (2,))
>>> op([1., 2., 3., 4.])
array([ 10., 24.])
{% endhighlight %}


h5. Explicit input shape and implicit output shape

This case does not happen because the output shape can be obtained from the explicit input shape and the 'reshapein' method.


h5. Unconstrained input shape and implicit output shape

{% highlight python %}
>>> class Op(Operator):
        def __init__(self):
            Operator.__init__(self)
        def direct(self, input, output):
            output[::2,...] = input
            output[1::2,...] = input
        def reshapein(self, shapein):
            if shapein is None:
                return None
            return (2*shapein[0],) + shapein[1:]
>>> op = Op()
>>> op.shapein, op.shapeout
(None, None)
>>> op.reshapein((2,3))
(4,3)
>>> op([[1,2,3],[2,3,4]])
array([[1, 2, 3],
       [1, 2, 3],
       [2, 3, 4],
       [2, 3, 4]])
{% endhighlight %}


h5. Explicit input shape and unconstrained output shape

{% highlight python %}
>>> class Op(Operator):
        def __init__(self):
            Operator.__init__(self, shapein=2)
        def direct(self, input, output):
            output[...] = input[0] + input[1] * np.arange(output.size).reshape(output.shape)
>>> op = Op()
>>> op.shapein, op.shapeout
(None, None)
>>> output = np.empty((2,2))
>>> op([1,2], output)
array([[1,3],[5,7]])
{% endhighlight %}


h5. Unconstrained input shape and unconstrained output shape

{% highlight python %}
>>> class Op(Operator):
        def __init__(self):
            Operator.__init__(self)
        def direct(self, input, output):
            output[...] = np.sum(input)
>>> op = Op()
>>> op.shapein, op.shapeout
(None, None)
>>> output = np.empty((2,2))
>>> op([2,1], output)
array([[3., 3.], [3., 3.]])
{% endhighlight %}
