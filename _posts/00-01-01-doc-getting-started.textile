---
layout: post
title: 1. Getting started
published: true
category: doc
---

The pyoperators package defines operators and solvers for high-performance computing. These operators are multi-dimensional functions with optimised and controlled memory management. If linear, they behave like matrices with a sparse storage footprint.

To define an operator, one needs to define a direct function which will replace the usual matrix-vector operation:

{% highlight python %}
>>> def f(x, out):
...     out[...] = 2 * x
{% endhighlight %}

Then, you can instantiate an @Operator@:

{% highlight python %}
>>> A = pyoperators.Operator(direct=f, flags='symmetric')
{% endhighlight %}

This operator does not have an explicit shape, it can handle inputs of any shape:

{% highlight python %}
>>> A(ones(5))
Info: Allocating (5,) float64 = 40 bytes in Operator.
array([ 2.,  2.,  2.,  2.,  2.])
>>> A(ones((2,3)))
Info: Allocating (2,3) float64 = 48 bytes in Operator.
array([[ 2.,  2.,  2.],
       [ 2.,  2.,  2.]])
{% endhighlight %}

By setting the 'symmetric' flag, we ensure that A's transpose is A:

{% highlight python %}
>>> A.T is A
True
{% endhighlight %}

To output a corresponding dense matrix, one needs to specify the input shape:

{% highlight python %}
>>> A.todense(shapein=2)
array([[ 2.,  0.],
       [ 0.,  2.]])
{% endhighlight %}

Operators do not have to be linear, but if they are not, they cannot be seen as matrices. Some operators are already predefined, such as the linear operators @IdentityOperator@ and @DiagonalOperator@ or the nonlinear operator @ClippingOperator@.

The previous @A@ matrix could be defined more easily like this :

{% highlight python %}
>>> A = 2 * pyoperators.I
{% endhighlight %}

where @I@ is the identity operator with no explicit shape.

Operators can be combined together by addition, element-wise multiplication or composition (note that the @*@ sign stands for composition):

{% highlight python %}
>>> B = 2 * pyoperators.I + pyoperators.DiagonalOperator(arange(3))
>>> B.todense()
array([[ 2.,  0.,  0.],
       [ 0.,  3.,  0.],
       [ 0.,  0.,  4.]])
{% endhighlight %}

Algebraic rules are used to simplify an expression involving operators, so to speed up its execution:

{% highlight python %}
>>> B
DiagonalOperator(array([ 2.,  3.,  4.]))
{% endhighlight %}
